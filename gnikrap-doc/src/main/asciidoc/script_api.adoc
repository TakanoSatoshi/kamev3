== Script API

// ///////////////////////////////////////////////////////////////////////////
=== General principles
// ///////////////////////////////////////////////////////////////////////////

The API has been designed to be simple to use. Here are some explanation that will help you to use
the API in a more efficient way:

* Single entry point: All the API can be accessed from the a single object: `ev3` (see <<The ev3 object>> for more details).
** All the stuff physically linked to the EV3 brick can be accessed from the object: `ev3.getBrick()` (see <<The ev3 object>> for more details).
* Method naming convention (don't be afraid, there is nothing exotic here) : 
** All the methods names starts with an verb.
** All the methods starting by `is` always returns a boolean (i.e. `true` or `false`).
** All the methods starting with `get` are 'getters' and will return a value.
** All the methods starting with `set` are 'setters' and will set a value.
** The API is English based.
* All the times are expressed in milliseconds (1 second is equals to 1000 milliseconds).
* All the angles are expressed in degrees (in general negative and positive degrees are accepted).



// ///////////////////////////////////////////////////////////////////////////
=== The ev3 object
// ///////////////////////////////////////////////////////////////////////////

****
isOk():: Enable to known is everything is ok and the script can continue running not. Returns `true` if the script can continue running, `false` if the script should stop.

getBrick():: Returns <<The Brick object>>.

notify(text):: Display a message on the Gnikrap interface. +
              `text` the text of the message to display.

sleep(timeInMs):: Make the script sleeping for the given number of milliseconds. +
                  `timeInMs` the sleeping time (in milliseconds).

getConfiguration():: Returns a <<Configuration object>>. Enable to configure some behaviour of the scripting environment.

getXSensor(XSensorName):: Returns <<The XSensor object>> for the XSensor with the given name. (The name is configured within the GUI)
                         `XSensorName` the name of the sensor.
****


==== Configuration object

[WARNING]
====
Configuration object is for advanced use only. If you don't understand what it means, don't use this object.
====

****
setIsOkCheckEscapeKey(checkEscapeKey)::  Enable the check of the kbd:[Escape] Mindstrom brick key when
                                         `isOk()` is called. *Default is `true`*. +
                                         `checkEscapeKey` if `true` check the kbd:[Escape] key, if `false` don't check nothing.

isIsOkCheckEscapeKey(checkEscapeKey):: Returns `true` if kbd:[Escape] key check on `isOk()` is enabled, `false` otherwise (don't check).

setIsOkWait(timeInMs):: Set the time to wait when `isOk()` is called. *Default is `0` (no waiting time)*. +
                        `timeInMs` the time to wait, `0` means no wait.

getIsOkWait():: Returns the time to wait when `isOk()` is called.

setWaitingTimeBeforeHardKill(timeInMs)::  Set a maximum time to wait before hard killing the script (eg. infinite loop).
                                          *Default is 5000 (5 seconds)*. +
                                          `timeInMs` the time to wait before hard killing the script. Valid values between 500 and 30000.

getWaitingTimeBeforeHardKill()::  Returns the time to wait before hard killing the script.
****


// ///////////////////////////////////////////////////////////////////////////
=== The Brick object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
getMediumMotor(port):: Return a <<The Motor object,medium Motor>> object for the given port. +
                       `port` value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getLargeMotor(port):: Return a <<The Motor object,large Motor>> object for the given port. +
                      `port` value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getColorSensor(port):: Return a <<The Color sensor object,Color sensor object>> for the given port. +
                       `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getIRSensor(port):: Return an <<The IR (Infra-Red) sensor object,Infra-Red sensor>> object for the given port. +
                    `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getTouchSensor(port):: Return a <<The Touch sensor object,Touch sensor>> object for the given port. +
                       `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getKeyboard():: Return <<The Keyboard object, Keyboard object>>.

getLed():: Return the <<The Led object,Led object>>.

getSound():: Return the <<The Sound object,Sound object>>.

getScreen():: Return the <<The Screen object,Screen object>>.

getBattery():: Return the <<The Battery object,Battery object>>.
****

See the others objects in order to have sample usage of the brick object.


// ///////////////////////////////////////////////////////////////////////////
=== The Motor object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/MotorMedium.png[Medium motor, 300, 200, float="right"]
image::ev3/MotorLarge.png[Large motor, 300, 200, align="left"]

[TIP]
====
On the motor API, some call wait that the operation is ended on the motor (so when the
function returns the motor has ended the expected move) while other immediately returns (so
the motor is still operating/moving while the function returns). The behaviour is specified for each function.
====

****
forward():: Motor rotate forward until `stop()`. This call immediately return.

backward():: Motor rotate backward until `stop()`. This call immediately return.

stop():: Stop and lock the motor. This call immediately return.

stop(lock):: Stop and lock or not the motor. This call immediately return. +
             `lock` is the motor locked ? Value should be in [`true`, `false`]

stop(lock, immediateReturn):: Stop and lock or not the motor. +
                              `lock` should be in [`true`, `false`] +
                              `immediateReturn` Is the function returns immediately or wait that the motor was locked ?
                              Values should be in [`true`, `false`]

rotate(angle):: Rotate the given number of degree. This call wait the end of the motor move. +
                `angle` the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.

rotate(angle, immediateReturn):: Rotate the given number of degree. This call wait the end of the motor move. +
                                 `angle` the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.
                                 `immediateReturn` Is the function returns immediately or wait that the motor rotation was ended ?
                                 Values should be in [`true`, `false`]

isMoving():: Returns `true` if the motors is currently moving, `false` otherwise.

getTachoCount():: Returns the tacho count in degree of the motor (_i.e._ the degree rotated since the last `resetTachoCount`).

resetTachoCount():: Reset the tacho count to `0`.

setSpeedPercent(percent):: Set the speed in percent of the maximum speed. +
                           `percent` the speed in percent of the maximum speed, 100 is full speed, 1 is minimum speed.

getSpeedPercent():: Get the speed in percent of the maximum speed.

setSpeed(degreePerSecond):: Set the speed in degrees per second. +
                            `degreePerSecond` the number of degrees per second that the motor should target ; one motor rotation is 360 degrees.
                             According to the LEGO documentation, the maximum sustainable speed is 960° per second for the large motor (i.e. 160 rotation per minute as claimed in the documentation)
                             and 1440° per second for the medium motor (i.e. 240 rotation per minute as claimed in the documentation).
                             In all cases, it seems that the maximum sustainable speed is 100 * battery voltage (which is lower than 900)

getSpeed():: Get the speed in degrees per second.
****

Sample code for the Motor object:

[source,javascript]
----
var largeMotor = ev3.getBrick().getLargeMotor("B");

// Rotate and wait end of rotation
largeMotor.rotate(360);
largeMotor.setSpeedPercent(100);
largeMotor.rotate(-360);

// Retrieve tacho
largeMotor.rotate(60);
ev3.notify("TachoA: " + largeMotor.getTachoCount());
largeMotor.rotate(-60);
ev3.notify("TachoB: " + largeMotor.getTachoCount());
largeMotor.resetTachoCount();
ev3.notify("TachoC: " + largeMotor.getTachoCount());

// Rotate and don't wait
var tacho;
largeMotor.rotate(360 * 3, true);
while((tacho = largeMotor.getTachoCount()) < 1000) {
  ev3.notify("Tacho: " + tacho);
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Color sensor object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/ColorSensor.png[Color sensor, 300, 200, align="center"]

****
getReflectedLight():: Returns the reflected light: a value between 0 and 100.

getAmbientLight():: Returns the ambient light: a value between 0 and 100.

getColor():: Returns a <<Color object>>.
****

==== Color object

****
getValue():: Returns the color values as a number.

isNoColor():: Returns `true` if no color was detected, `false` otherwise.

isBlack():: Returns `true` if the black color was detected, `false` otherwise.

isBlue():: Returns `true` if the blue color was detected, `false` otherwise.

isYellow():: Returns `true` if the yellow color was detected, `false` otherwise.

isRed():: Returns `true` if the red color was detected, `false` otherwise

isWhite():: Returns `true` if the white color was detected, `false` otherwise.

isBrown():: Returns `true` if the brown color was detected, `false` otherwise.

getColorAsText:: Returns the color as a string.
****


Sample code for the color sensor:
[source,javascript]
.Reflected light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Reflected light: " + colorSensor.getReflectedLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Ambient light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Ambient light: " + colorSensor.getAmbientLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Color API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Color: " + colorSensor.getColor());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The IR (Infra-Red) sensor object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/IRSensor.png[IR sensor, 300, 200, align="center"]

****
setChannel(channel):: Set the channel to use with the IR sensor. +
                      `channel` the channel number, value should be in [1, 2, 3, 4].

getChannel():: Return the channel currently used.

getDistance():: Returns the distance for the IR sensor to something in cm, the value is from 0 to 100cm.

getRemoteCommand():: Check for remote command (beacon) buttons usage. Returns a <<RemoteCommandResult object>>.

seekBeacon():: Look for the beacon and returns a <<SeekBeaconResult object>>.
****


==== RemoteCommandResult object

image::ev3/IRBeacon.png[IR Beacon, 300, 200, align="center"]

****
getValue():: Returns integer value of the remote beacon.

isTopLeftEnabled():: Returns `true` if the top left button was pressed, `false` otherwise.

isTopRightEnabled():: Returns `true` if the top right button was pressed, `false` otherwise.

isBottomLeftEnabled():: Returns `true` if the bottom left button was pressed, `false` otherwise.

isBottomRightEnabled():: Returns `true` if the bottom right button was pressed, `false` otherwise.

isBeaconEnabled():: Returns `true` if beacon mode was enabled, `false` otherwise.

isNothingEnabled():: Returns `true` nothing was enabled, `false` otherwise.
****

==== SeekBeaconResult object

image::ev3/IRBeacon.png[IR Beacon, 300, 200, align="center"]

****
isBeaconFound():: Returns `true` if the beacon was detected, `false` otherwise.

getBearing():: Returns the beacon bearing value from -12 to 12 (with values increasing clockwise when looking from behind the sensor.
               A bearing of 0 indicates the beacon is directly in front of the sensor).

getDistance():: Returns beacon distance in cm from 0 to 100cm. If the beacon is not found, 128 was returned.

isBeaconFound(channel):: Same as `isBeaconFound()` on the given channel.

getBearing(channel):: Same as `getBearing()` on the given channel.

getDistance(channel):: Same as `getDistance()` on the given channel.
****


Sample code for the IR sensor object:

[source,javascript]
.Distance API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Distance: " + irSensor.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Seek beacon API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.seekBeacon();
  ev3.notify("Beacon found: " + x.isBeaconFound() + ", bearing: " + x.getBearing() + ", distance: " + x.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Remote command API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.getRemoteCommand();
  ev3.notify("value: " + x.getValue() + 
            ", tl: " + x.isTopLeftEnabled() + ", tr: " + x.isTopRightEnabled() + 
            ", bl: " + x.isBottomLeftEnabled() + ", br: " + x.isBottomRightEnabled() + 
            ", bea: " + x.isBeaconEnabled() + " nothing: " + x.isNothingEnabled());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Touch sensor object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/TouchSensor.png[Touch sensor, 300, 200, align="center"]

****
isPushed():: Returns `true` if the sensor was pushed, `false` otherwise.
****

Sample code for the Touch sensor object
[source,javascript]
----
// Touch sensor API
var touchSensor = ev3.getBrick().getTouchSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Push button: " + touchSensor.isPushed());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Keyboard object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
getDown():: Returns a <<Button object>> for the kbd:[Down] button.

getEnter():: Returns a <<Button object>> for the kbd:[Enter] button.

getEscape():: Returns a <<Button object>> for the kbd:[Escape] button. +
              _Note:_ The kbd:[Escape] button can also be checked by the `isOk()` function.

getLeft():: Returns a <<Button object>> for the kbd:[Left] button.

getRight():: Returns a <<Button object>> for the kbd:[Right] button.

getUp():: Returns a <<Button object>> for the kbd:[Up] button.

waitForAnyPress():: Wait for some button to be pressed. Returns the id of the button that has been pressed.

getLed():: Returns a <<The Led object,Led object>>. The Led object enable to pilot the LED integrated to the Mindstorm brick keyboard.
****


==== Button object

****
isUp():: Returns `true` if the button is up, `false` otherwise.

isDown():: Returns `true` if the button is down, `false` otherwise.

waitForPress():: Wait until the button has been pressed.

waitForPressAndRelease():: Wait until the button has been pressed and released.

getId():: Returns the id (number) of the button.
****


Sample code for the Keyboard object:
[source,javascript]
----
// Keyboard API
var enterKey = ev3.getBrick().getKeyboard().getEnter();
ev3.notify("Press enter to continue");
while(enterKey.isUp() && ev3.isOk()) {
  ev3.sleep(200);
}
ev3.notify("Enter - Down: " + enterKey.isDown() + " / Up: " + enterKey.isUp());
----


// ///////////////////////////////////////////////////////////////////////////
=== The Led object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
off():: Disable the LED.

lightGreen():: Enable the green LED.

lightRed():: Enable the red LED.

lightOrange():: Enable the orange LED.

blink():: Set the LED blinking. Note calling once blink set the 1st mode, calling twice, set the 2nd mode and calling 3 time don't blink anymore.
****


Sample code for the Led object:
[source,javascript]
----
// Led API
var leds = ev3.getBrick().getLed();
leds.lightGreen();
ev3.sleep(2000);
leds.lightOrange().blink();
ev3.sleep(2000);
leds.lightRed().blink().blink();
ev3.sleep(2000);
leds.off();
----


// ///////////////////////////////////////////////////////////////////////////
=== The Sound object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
setVolume(vol):: Set the sound volume. +
                 `vol` the volume, valid values are between 0 and 100.

getVolume():: Returns the sound volume.

beep():: Play a beep.

playTone(frequency, durationInMs):: Play a tone of the given frequency for the given duration. +
                                    `frequency` the frequency of the tone in Hertz (Hz). Note: In order to be audible, use values between 50 and 2000. +
                                    `durationInMs` the duration in milliseconds.

playNote(note, durationInMs):: Play the given note for the given duration. +
                               `note` the note to play. Notes should be in ["C1"-"B7", # allowed on C, D, F, G, A] or ["Do"-"Si", # allowed on Do, Re, Fa, Sol, La]. +
                               `durationInMs` the duration in milliseconds.
****


Sample script with Sound object:
[source,javascript]
----
// Sound API
var sound = ev3.getBrick().getSound();
sound.setVolume(90);
sound.beep();
for(freq = 50; freq < 1500; freq = freq + 10) {
  sound.playTone(freq, 5);
}
sound.playNote("Do", 500);
sound.playNote("Re", 500);
sound.playNote("Mi", 500);
sound.playNote("Fa", 500);
sound.playNote("Sol", 500);
sound.playNote("La", 500);
sound.playNote("Si", 500);
----


// ///////////////////////////////////////////////////////////////////////////
=== The Screen object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
clear():: Clear the LCD screen.

TODO - other methods currently not working.
****


// ///////////////////////////////////////////////////////////////////////////
=== The Battery object
// ///////////////////////////////////////////////////////////////////////////

image::ev3/Brick.png[EV3 Brick, 300, 200, align="center"]

****
getBatteryCurrent():: Returns current draw from the battery (in Amps).

getMotorCurrent():: Returns current draw by the motors (in Amps).

getVoltageMilliVolt():: Battery voltage in mV. ~9000 = full.
****


Sample script with Battery object:
[source,javascript]
----
// Battery API
var battery = ev3.getBrick().getBattery();
ev3.notify("Battery current: " + battery.getBatteryCurrent());
ev3.notify("Motor current: " + battery.getMotorCurrent());
ev3.notify("Voltage: " + battery.getVoltageMilliVolt());
----

// ///////////////////////////////////////////////////////////////////////////
=== The XSensor object
// ///////////////////////////////////////////////////////////////////////////

There is API common to all XSensors:

****
getName():: Returns the name of the XSensor.

getValue():: Returns the *current* value of the XSensor. It is *IMPORTANT* to note that two successive calls to `getValue()` can 
             return different value if the sensor has been modified meantime.
****


[TIP]
====
For all XSensor values there is function `isStarted()` that returns `true` if started or `false` if not. *If the XSensor
isn't started (i.e. `isStarted` returns `false`), all the other methods on the value object will not be available: If you even try to call
these methods, the script could be stopped (by an exception).*
====


==== The xTouch XSensor

image::xsensor/xTouch_001_configure.png[xTouch, 640, 400, align="center"]

In the screen, you can:

* Set the sensor name (in our example: "joystick").
* Configure the xTouch sensor: Set the buttons 'actions': While not started, click on a button and set the list of actions (comma separated) for the button.
* Start the xTouch sensor: While a button was clicked, the value of the sensor was updated. On multi-touch devices, you can click several buttons at the same time.
+
Note: While started, the buttons not configured (without associated actions) will be disabled. 


Here are the fields available on the XTouch XSensor:

[NOTE]
====
Only the *active* touches are available within the XSensor values.
====

****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

containsTouch(name):: Returns `true` if the touch is available, that is to say active, `false` otherwise. +
                      `name` the name of the touch to look for.

getTouch(name):: Returns a <<Touch object>> for the given touch. +
                 `name` the name of the touch to look for.

getTouches():: Returns an array of all the <<Touch object>>s available.
****

===== Touch object

****
getName():: Returns the name of the touch.

getHits():: Returns the number of simultaneous hits for the touch (several touch can have the same name).
****


Sample script with xTouch XSensor:
[source,javascript]
----
// xTouch XSensor
// Configure the xTouch sensor with at least one touch "up"
var xTouch = ev3.getXSensor("xTouch");
while(ev3.isOk()) {
  var value = xTouch.getValue();
  if(value.isStarted()) {
    if(value.containsTouch("up")) {
      ev3.notify("You have clicked the 'up' touch !");
    } else {
      ev3.notify("Click on 'up'");
    }
  }
  
  ev3.sleep(100);
}
----


==== The xGyro XSensor

image::xsensor/xGyro_001_running.png[xGyro, 640, 400, align="center"]

In the screen, you can:

* Set the sensor name (in our example: "xGyro").
* Set the orientation of the device (portrait/left landscape/right landscape, reverse portrait) in order to have the right values.
* Start the xGyro sensor.

[TIP]
====
In order to avoid annoying screen rotation, think to disabled the 'auto rotate' on your device while using the xGyro sensor.
====


****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

getX():: Returns an <<Axis object>>. +
         X is the front-back tilt in degrees where front is positive (also known as 'beta' with 'Portrait' orientation).

getY():: Returns an <<Axis object>>. +
         Y is the left-right tilt in degrees, where right is positive (also known as 'gamma' with 'Portrait' orientation)

getZ():: Returns an <<Axis object>>. +
         The compass direction of the device in degrees (also known as 'alpha').  +
         _Note_: Some devices don't support compass (the z value will always be 0). For some devices, the compass don't returns the angle with the north.
****


===== Axis object

****
getAngle():: Returns the angle in degrees
****

Sample script with xGyro XSensor:
[source,javascript]
----
// xGyro XSensor
var xGyro = ev3.getXSensor("xGyro");

while(ev3.isOk()) {
  var value = xGyro.getValue();
  if(value.isStarted()) {
    var y = value.getY().getAngle();
    var x = value.getX().getAngle();
    
    ev3.notify("XGyro - x: " + x + ", y: " + y);
  }
  
  ev3.sleep(100);
}
----


==== The xVideo XSensor

In the screen, you can:

* Start the xVideo sensor. Once started the browser will certainly ask you to select the webcam to use (and to give the authorization to
  use this webcam).
* Select objects to track: Once started, click on the video to select the objects to track. You can give the name you want to the object.
  You can also change the name by clicking again on the object.

[TIP]
====
.There is several important point to note about the tracking algorithm used:
- Under 20 FPS (frame per seconds), the object will be often loosed (_The number of FPS is displayed above the video_).
- Tracking objects with an important black/white contrast is the best option (i.e. objects with with and black surface that are visible from the camera).
  On the opposite, tracking object with uniform colour don't work very well.
- If there is something (even for a very short time) between the camera and the tracked object, the object will be loosed.
- You can move the camera (not too quickly) without any problem.
- Your object can move/rotate/etc. without any problem.


Note: The algorithm used was the Lucas-Kanade method (See http://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method[wikipedia] for more details).
====


****
isStarted():: Returns `true` if the XSensor is started, `false` otherwise.

containsObject(name):: Returns `true` if the object is available, that is to say tracked, `false` otherwise. +
                      `name` the name of the object to look for.

getObject(name):: Returns a <<VisibleObject object>> for the given object. +
                 `name` the name of the object to look for.

getObjects():: Returns an array of all the <<VisibleObject object>>s available.
****

===== VisibleObject object

****
getName():: Returns the name of the object.

getX():: Returns the x value for this object (x goes from 0 to 640).

getY():: Returns the y value for this object (y goes from 0 to 480).
****

Sample script with xVideo XSensor:
[source,javascript]
----
// xVideo XSensor
// Configure the xVideo sensor to track one object called "myTarget"
var xVideo = ev3.getXSensor("xVideo");
while(ev3.isOk()) {
  var value = xVideo.getValue();
  if(value.isStarted()) {
    if(value.containsObject("myTarget")) {
      var t = value.getObject("myTarget");
      ev3.notify("Target found: [" + t.getX() + ", " + t.getY() + "]");
    } else {
      ev3.notify("Hey, select a target called 'myTarget'");
    }
  }
  
  ev3.sleep(100);
}
----


==== Advanced usage

You can use several xSensor at the same time. Theses sensors can be on the same device or on several devices.
For example, you can run on the same device the xGyro sensor and the xTouch sensor. Another example could be 
to run the xGyro sensor on one device and the xVideo sensor on another device.

[IMPORTANT]
====
.However it is recommended to limit to:
- 4 active XSensor at the same time _(xGyro and xVideo sensor always generate new values => 
  Sending the values of more than 4 sensors at the same time can flood the EV3 brick)_.
- 2 devices connected to the EV3 at the same time _(The network bandwidth available on
  the EV3 brick is quite limited, especially with bluetooth, so 2 is ok, more can be challenging).

====


A note on the behaviour of the function `ev3.ìsOk()` while using XSensors: Even if not configured (see <<Configuration object>>)
this method will automatically wait a bit while one or several XSensors are actively sending data to the brick. This waiting time
will be automatically reset while there is no more active XSensors. +
_Note_: The aim of this small waiting time is to let the EV3 CPU process the XSensors incoming events in a proper way.
