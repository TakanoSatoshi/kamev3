== Script API

// ///////////////////////////////////////////////////////////////////////////
=== General principles
// ///////////////////////////////////////////////////////////////////////////

The API has been designed to be simple to use. Here are some explanation that will help you to use
the API in a more efficient way:

* Single entry point: All the API can be accessed from the a single object: `ev3` (see <<The ev3 object>> for more details).
** All the stuff physically linked to the EV3 brick can be accessed from the object: `ev3.getBrick()` (see <<The ev3 object>> for more details).
* Method naming convention (don't be afraid, there is nothing exotic here) : 
** All the methods names starts with an verb.
** All the methods starting by `is` always returns a boolean (i.e. `true`or `false`).
** All the methods starting with `get` are 'getters' and will return a value.
** All the methods starting with `set` are 'setters' and will set a value.
** The API is English based (However, if requested API translation could be done).
* All the times are expressed in milliseconds (1 second is equals to 1000 milliseconds).
* All the angles are expressed in degrees (in general negative and positive degrees are accepted).



// ///////////////////////////////////////////////////////////////////////////
=== The ev3 object
// ///////////////////////////////////////////////////////////////////////////

****
isOk():: Enable to known is everything is ok and the script can conitnue running not. Returns `true` if the script can continue running, `false` if the script should stop.

getBrick():: Returns <<The Brick object>>.

notify(text):: Display a message on the Gnikrap interface. +
              `text` the text of the message to display.

sleep(timeInMs):: Make the script sleeping for the given number of milliseconds. +
                  `timeInMs` the sleeping time (in milliseconds).

getConfiguration():: Returns a <<Configuration object>>. Enable to configure some behaviour of the scripting environment.

getXSensor(XSensorName):: Returns <<The XSensor object>> for the XSensor with the given name. (The name is configured within the GUI)
                         `XSensorName` the name of the sensor.
****


==== Configuration object

[NOTE]
====
Configuration object is for advanced use only. If you don't uderstand what it means, don't use this object.
====

****
setIsOkCheckEscapeKey(checkEscapeKey)::  Enable the check of the kbd:[Escape] Mindstrom brick key when
                                         `isOk()` is called. *Default is `true`*. +
                                         `checkEscapeKey` if `true` check the kbd:[Escape] key, if `false` don't check nothing.

isIsOkCheckEscapeKey(checkEscapeKey):: Returns `true` if kbd:[Escape] key check on `isOk()` is enabled, `false` otherwise (don't check).

setIsOkWait(timeInMs):: Set the time to wait when `isOk()` is called. *Default is `0` (no waiting time)*. +
                        `timeInMs` the time to wait, `0` means no wait.

getIsOkWait():: Returns the time to wait when `isOk()` is called.

setWaitingTimeBeforeHardKill(timeInMs)::  Set a maximum time to wait before hard killing the script (eg. infinite loop).
                                          *Default is 5000 (5 seconds)*. +
                                          `timeInMs` the time to wait before hard killing the script. Valid values between 500 and 30000.

getWaitingTimeBeforeHardKill()::  Returns the time to wait before hard killing the script.
****


// ///////////////////////////////////////////////////////////////////////////
=== The Brick object
// ///////////////////////////////////////////////////////////////////////////

****
getMediumMotor(port):: Return a <<The Motor object,medium Motor>> object for the given port. +
                       `port` value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getLargeMotor(port):: Return a <<The Motor object,large Motor>> object for the given port. +
                      `port` value should be in [`"A"`, `"B"`, `"C"`, `"D"`].

getColorSensor(port):: Return a <<The Color sensor object,Color sensor object>> for the given port. +
                       `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getIRSensor(port):: Return an <<The IR (Infra-Red) sensor object,Infra-Red sensor>> object for the given port. +
                    `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getTouchSensor(port):: Return a <<The Touch sensor object,Touch sensor>> object for the given port. +
                       `port` value should be in [`"1"`, `"2"`, `"3"`, `"4"`] or [`"S1"`, `"S2"`, `"S3"`, `"S4"`].

getKeyboard():: Return <<The Keyboard object, Keyboard object>>.

getLed():: Return the <<The Led object,Led object>>.

getSound():: Return the <<The Sound object,Sound object>>.

getScreen():: Return the <<The Screen object,Screen object>>.

getBattery():: Return the <<The Battery object,Battery object>>.
****

See the others objects in order to have sample usage of the brick object.


// ///////////////////////////////////////////////////////////////////////////
=== The Motor object
// ///////////////////////////////////////////////////////////////////////////

[NOTE]
====
On the motor API, some call wait that the operation is ended on the motor (so when the
function returns the motor has ended the expected move) while other immediately returns (so
the motor is still operating/moving while the function returns). The behaviour is specified for each function.
====

****
forward():: Motor rotate forward until `stop()`. This call immediately return.

backward():: Motor rotate backward until `stop()`. This call immediately return.

stop():: Stop and lock the motor. This call immediately return.

stop(lock):: Stop and lock or not the motor. This call immediately return. +
             `lock` is the motor locked ? Value should be in [`true`, `false`]

stop(lock, immediateReturn):: Stop and lock or not the motor. +
                              `lock` should be in [`true`, `false`] +
                              `immediateReturn` Is the function returns immediately or wait that the motor was locked ?
                              Values should be in [`true`, `false`]

rotate(angle):: Rotate the given number of degree. This call wait the end of the motor move. +
                `angle` the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.

rotate(angle, immediateReturn):: Rotate the given number of degree. This call wait the end of the motor move. +
                                 `angle` the number of degree to rotate. Positive number will rotate forward, negative will rotate backward.
                                 `immediateReturn` Is the function returns immediately or wait that the motor rotation was ended ?
                                 Values should be in [`true`, `false`]

isMoving():: Returns `true` if the motors is currently moving, `false` otherwise.

getTachoCount():: Returns the tacho count in degree of the motor (_i.e._ the degree rotated since the last `resetTachoCount`).

resetTachoCount():: Reset the tacho count to `0`.

setSpeedPercent(percent):: Set the speed in percent of the maximum speed. +
                           `percent` the speed in percent of the maximum speed, 100 is full speed, 1 is minimum speed.

getSpeedPercent():: Get the speed in percent of the maximum speed.

setSpeed(degreePerSecond):: Set the speed in degrees per second. +
                            `degreePerSecond` the number of degrees per second that the motor should target ; one motor rotation is 360 degrees.
                             According to the LEGO documentation, the maximum sustainable speed is 960° per second for the large motor (i.e. 160 rotation per minute as claimed in the documentation)
                             and 1440° per second for the medium motor (i.e. 240 rotation per minute as claimed in the documentation).
                             In all cases, it seems that the maximum sustainable speed is 100 * battery voltage (which is lower than 900)

getSpeed():: Get the speed in degrees per second.
****

Sample code for the Motor object:

[source,javascript]
----
var largeMotor = ev3.getBrick().getLargeMotor("B");

// Rotate and wait end of rotation
largeMotor.rotate(360);
largeMotor.setSpeedPercent(100);
largeMotor.rotate(-360);

// Retrieve tacho
largeMotor.rotate(60);
ev3.notify("TachoA: " + largeMotor.getTachoCount());
largeMotor.rotate(-60);
ev3.notify("TachoB: " + largeMotor.getTachoCount());
largeMotor.resetTachoCount();
ev3.notify("TachoC: " + largeMotor.getTachoCount());

// Rotate and don't wait
var tacho;
largeMotor.rotate(360 * 3, true);
while((tacho = largeMotor.getTachoCount()) < 1000) {
  ev3.notify("Tacho: " + tacho);
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Color sensor object
// ///////////////////////////////////////////////////////////////////////////

****
getReflectedLight():: Returns the reflected light: a value between 0 and 100.

getAmbientLight():: Returns the ambient light: a value between 0 and 100.

getColor():: Returns a <<Color object>>.
****

==== Color object

****
getValue():: Returns the color values as a number.

isNoColor():: Returns `true` if no color was detected, `false` otherwise.

isBlack():: Returns `true` if the black color was detected, `false` otherwise.

isBlue():: Returns `true` if the blue color was detected, `false` otherwise.

isYellow():: Returns `true` if the yellow color was detected, `false` otherwise.

isRed():: Returns `true` if the red color was detected, `false` otherwise

isWhite():: Returns `true` if the white color was detected, `false` otherwise.

isBrown():: Returns `true` if the brown color was detected, `false` otherwise.

getColorAsText:: Returns the color as a string.
****


Sample code for the color sensor:
[source,javascript]
.Reflected light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Reflected light: " + colorSensor.getReflectedLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Ambiant light API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Ambiant light: " + colorSensor.getAmbientLight());
  ev3.sleep(200);
}
----

[source,javascript]
.Color API:
----
var colorSensor = ev3.getBrick().getColorSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Color: " + colorSensor.getColor());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The IR (Infra-Red) sensor object
// ///////////////////////////////////////////////////////////////////////////

****
setChannel(channel):: Set the channel to use with the IR sensor. +
                      `channel` the channel number, value should be in [1, 2, 3, 4].

getChannel():: Return the channel currently used.

getDistance():: Returns the distance for the IR sensor to something in cm, the value is from 0 to 100cm.

getRemoteCommand():: Check for remote command (beacon) buttons usage. Returns a <<RemoteCommandResult object>>.

seekBeacon():: Look for the beacon and returns a <<SeekBeaconResult object>>.
****


==== RemoteCommandResult object

****
getValue():: Returns integer value of the remote beacon.

isTopLeftEnabled():: Returns `true` if the top left button was pressed, `false` otherwise.

isTopRightEnabled():: Returns `true` if the top right button was pressed, `false` otherwise.

isBottomLeftEnabled():: Returns `true` if the bottom left button was pressed, `false` otherwise.

isBottomRightEnabled():: Returns `true` if the bottom right button was pressed, `false` otherwise.

isBeaconEnabled():: Returns `true` if beacon mode was enabled, `false` otherwise.

isNothingEnabled():: Returns `true` nothing was enabled, `false` otherwise.
****

==== SeekBeaconResult object

****
isBeaconFound():: Returns `true` if the beacon was detected, `false` otherwise.

getBearing():: Returns the beacon bearing value from -12 to 12 (with values increasing clockwise when looking from behind the sensor.
               A bearing of 0 indicates the beacon is directly in front of the sensor).

getDistance():: Returns beacon distance in cm from 0 to 100cm. If the beacon is not found, 128 was returned.

isBeaconFound(channel):: Same as `isBeaconFound()` on the given channel.

getBearing(channel):: Same as `getBearing()` on the given channel.

getDistance(channel):: Same as `getDistance()` on the given channel.
****


Sample code for the IR sensor object:

[source,javascript]
.Distance API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Distance: " + irSensor.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Seek beacon API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.seekBeacon();
  ev3.notify("Beacon found: " + x.isBeaconFound() + ", bearing: " + x.getBearing() + ", distance: " + x.getDistance());
  ev3.sleep(200);
}
----

[source,javascript]
.Remote command API:
----
var irSensor = ev3.getBrick().getIRSensor("S1");
while(ev3.isOk()) {
  var x = irSensor.getRemoteCommand();
  ev3.notify("value: " + x.getValue() + 
            ", tl: " + x.isTopLeftEnabled() + ", tr: " + x.isTopRightEnabled() + 
            ", bl: " + x.isBottomLeftEnabled() + ", br: " + x.isBottomRightEnabled() + 
            ", bea: " + x.isBeaconEnabled() + " nothing: " + x.isNothingEnabled());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Touch sensor object
// ///////////////////////////////////////////////////////////////////////////

****
isPushed():: Returns `true` if the sensor was pushed, `false` otherwise.
****

Sample code for the Touch sensor object
[source,javascript]
----
// Touch sensor API
var touchSensor = ev3.getBrick().getTouchSensor("S1");
while(ev3.isOk()) {
  ev3.notify("Push button: " + touchSensor.isPushed());
  ev3.sleep(200);
}
----


// ///////////////////////////////////////////////////////////////////////////
=== The Keyboard object
// ///////////////////////////////////////////////////////////////////////////

****
getDown():: Returns a <<Button object>> for the kbd:[Down] button.

getEnter():: Returns a <<Button object>> for the kbd:[Enter] button.

getEscape():: Returns a <<Button object>> for the kbd:[Escape] button. +
              _Note:_ The kbd:[Escape] button can also be checked by the `isOk()` function.

getLeft():: Returns a <<Button object>> for the kbd:[Left] button.

getRight():: Returns a <<Button object>> for the kbd:[Right] button.

getUp():: Returns a <<Button object>> for the kbd:[Up] button.

waitForAnyPress():: Wait for some button to be pressed. Returns the id of the button that has been pressed.

getLed():: Returns a <<The Led object,Led object>>. The Led object enable to pilot the LED integrated to the Mindstorm brick keyboard.
****


==== Button object

****
isUp():: Returns `true` if the button is up, `false` otherwise.

isDown():: Returns `true` if the button is down, `false` otherwise.

waitForPress():: Wait until the button has been pressed.

waitForPressAndRelease():: Wait until the button has been pressed and released.

getId():: Returns the id (number) of the button.
****


Sample code for the Keyboard object:
[source,javascript]
----
// Keyboard API
var enterKey = ev3.getBrick().getKeyboard().getEnter();
ev3.notify("Press enter to continue");
while(enterKey.isUp() && ev3.isOk()) {
  ev3.sleep(200);
}
ev3.notify("Enter - Down: " + enterKey.isDown() + " / Up: " + enterKey.isUp());
----


// ///////////////////////////////////////////////////////////////////////////
=== The Led object
// ///////////////////////////////////////////////////////////////////////////

****
off():: Disable the LED.

lightGreen():: Enable the green LED.

lightRed():: Enable the red LED.

lightOrange():: Enable the orange LED.

blink():: Set the LED blinking. Note calling once blink set the 1st mode, calling twice, set the 2nd mode and calling 3 time don't blink anymore.
****


Sample code for the Led object:
[source,javascript]
----
// Led API
var leds = ev3.getBrick().getLed();
leds.lightGreen();
ev3.sleep(2000);
leds.lightOrange().blink();
ev3.sleep(2000);
leds.lightRed().blink().blink();
ev3.sleep(2000);
leds.off();
----


// ///////////////////////////////////////////////////////////////////////////
=== The Sound object
// ///////////////////////////////////////////////////////////////////////////

****
setVolume(vol):: Set the sound volume. +
                 `vol` the volumne, valid values are betwwen 0 and 100.

getVolume():: Returns the sound volume.

beep()::Play a beep.

playTone(frequency, durationInMs):: Play a tone of the given frequency for the given duration. +
                                    `frequency` the frequency of the tone in Hertz (Hz). Note: In order to be audible, use values between 50 and 2000. +
                                    `durationInMs` the duration in milliseconds.

playNote(note, durationInMs):: Play the given note for the given duration. +
                               `note` the note to play. Notes should be in ["C1"-"B7", # allowed on C, D, F, G, A] or ["Do"-"Si", # allowed on Do, Re, Fa, Sol, La]. +
                               `durationInMs` the duration in milliseconds.
****


Sample script with Sound object:
[source,javascript]
----
// Sound API
var sound = ev3.getBrick().getSound();
sound.setVolume(90);
sound.beep();
for(freq = 50; freq < 1500; freq = freq + 10) {
  sound.playTone(freq, 5);
}
sound.playNote("Do", 500);
sound.playNote("Re", 500);
sound.playNote("Mi", 500);
sound.playNote("Fa", 500);
sound.playNote("Sol", 500);
sound.playNote("La", 500);
sound.playNote("Si", 500);
----


// ///////////////////////////////////////////////////////////////////////////
=== The Screen object
// ///////////////////////////////////////////////////////////////////////////

****
clear():: Clear the LCD screen.

TODO - other methods currently not working.
****


// ///////////////////////////////////////////////////////////////////////////
=== The Battery object
// ///////////////////////////////////////////////////////////////////////////

****
getBatteryCurrent():: Returns current draw from the battery (in Amps).

getMotorCurrent():: Returns current draw by the motors (in Amps).

getVoltageMilliVolt():: Battery voltage in mV. ~9000 = full.
****


Sample script with Battery object:
[source,javascript]
----
// Battery API
var battery = ev3.getBrick().getBattery();
ev3.notify("Battery current: " + battery.getBatteryCurrent());
ev3.notify("Motor current: " + battery.getMotorCurrent());
ev3.notify("Voltage: " + battery.getVoltageMilliVolt());
----

// ///////////////////////////////////////////////////////////////////////////
=== The XSensor object
// ///////////////////////////////////////////////////////////////////////////

There is API common to all XSensors:

****
getName():: Returns the name of the XSensor.

getValue():: Returns the *current* value of the XSensor. It is *IMPORTANT* to note that two successive calls to `getValue()` can 
             return different value if the sensor has been modified meantime.
****


[NOTE]
====
It is important to note that within the value of an XSensor, the data was retrieved by using a method that get 
the name of the field as parameter: In other words, `getXxxx()` will be written `get("xxxx")`.
====


[TIP]
====
You can see all the fields available for a XSensor by notifying it's value. For example for an xTouch sensor, a call to 
`ev3.notify(ev3.getXSensor("xTouch").getValue())` will display something like: `{touchs={TestTouch4=1, TestTouch8=1}, isStarted=true}`.

_In this example, we can see that the XSensor is started and that the TestTouch4 and TestTouch8 are enabled._

Note: The fields available for each sensor are documented in the following chapters.
====

==== The xTouch XSensor

image::xsensor/xTouch_001_configure.png[xTouch - configuration mode]

In the screen, you can:

* Set the sensor name (in our example: "joystick").
* Configure the xTouch sensor: Set the buttons 'names': While not started, click on a button and set the list of names (comma separated) for the given button.
* Start the xTouch sensor: configured Once started, each time a button was clicked the sensor value was updated.
+
Note: While started, only the buttons with a name will remains active. 


Here are the fields available on the XTouch XSensor:

****
isStarted:: Returns `true` if the XSensor is started, `false` otherwise.
****


Sample script with xTouch XSensor:
[source,javascript]
----
// xTouch XSensor
----


==== The xGyro XSensor

image::xsensor/xGyro_001_running.png[xGyro]

In the screen, you can:

* Set the sensor name (in our example: "xGyro")
* Set the orientation of the device (portrait/landscape) in order to have the right values.
* Start the xGyro sensor.

Here are the fields available on the xGyro XSensor:

****
isStarted:: Returns `true` if the XSensor is started, `false` otherwise.

x:: The front-back tilt in degrees where front is positive (also known as 'beta' with 'Portrait' orientation).
    Returns an object that contains only one field: `angle`. This field contains the angle of the device on this axis.

y:: The left-right tilt in degrees, where right is positive (also known as 'gamma' with 'Portrait' orientation)
    Same return value as x.

z:: The compass direction of the device in degrees (also known as 'alpha'). 
    Note: Some devices don't support compass (the z value will always be 0). For some devices, the compass don't returns the angle with the north.
    Same return value as x.
****

Sample script with xGyro XSensor:
[source,javascript]
----
// xGyro XSensor
var xGyro = ev3.getXSensor("xGyro");

while(ev3.isOk()) {
  var value = xGyro.getValue();
  if(value.get("isStarted")) {
    var y = value.get("y").get("angle");
    var x = value.get("x").get("angle");
    
    ev3.notify("XGyro - x: " + x + ", y: " + y);
  }
  
  ev3.sleep(100);
}
----


==== The xVideo XSensor

TODO
